using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System;

namespace ProjectEuler
{
    public class ProblemSolver
    {
        /// <summary>
        /// Set this to true if you want to skip problems whose solution is slow to calculate.
        /// Useful if you want to focus in your current problem without commenting a lot of stuff.
        /// </summary>
        const bool SkipSlow = false;

        public ProblemSolver()
        {
            // ## BEGIN OF HACK ##
            // "Waste" here the time with the reflection overload happening
            // in the 1st time we call the invoker, so that we do not affect
            // the measured time of the 1st problem with extra milliseconds.
            InvokeSolverMethod(1);
            // ## END OF HACK ##
        }

        /// <summary>
        /// Get the number or problems solved so far.
        /// </summary>
        /// <returns>The number of methods with "SolveProblem" in the name.</returns>
        public int NumberOfProblemsSolved
        {
            get
            {
                if (_numberOfProblemsSolved == -1)
                {
                    _numberOfProblemsSolved = this
                        .GetType()
                        .GetMethods()
                        .Where(m => m.Name.Contains("SolveProblem"))
                        .Count();
                }
                return _numberOfProblemsSolved;
            }
        }
        private int _numberOfProblemsSolved = -1;

        /// <summary>
        /// Solve a problem, calculating the time it takes to execute.
        /// </summary>
        /// <param name="problem">A given problem number to solve.</param>
        /// <returns>The solution to the problem, including execution metrics.</returns>
        public SolutionInfo Solve(ProblemInfo problem)
        {
            if (problem.HasSlowResolution && SkipSlow == true)
            {
                return SolutionInfo.GetSkippedSolution(problem.Number);
            }

            SolutionInfo solution = new SolutionInfo(problem.Number);

            var watch = new System.Diagnostics.Stopwatch();
            watch.Start();
            solution.ProblemSolution = InvokeSolverMethod(problem.Number);
            watch.Stop();

            solution.ExecutionTimeInMs = watch.ElapsedMilliseconds;
            solution.Skipped = false;
            solution.SolutionIsCorrect = (solution.ProblemSolution == problem.ExpectedSolution);

            return solution;
        }

        /// <summary>
        /// Runs the problem solver's method given a problem number.
        /// Expects that there is a method with name "SolveProblemXXXX",
        /// where XXXX is the problem number left padded with zeros.
        /// </summary>
        /// <param name="problemNumber">A given problem number.</param>
        /// <returns>The solution of the problem.</returns>
        private long InvokeSolverMethod(int problemNumber)
        {
            MethodInfo solverMethod = this
                .GetType()
                .GetMethod($"SolveProblem{problemNumber.ToString().PadLeft(4, '0')}");

            return (long)solverMethod.Invoke(this, null);
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 1
        /// Multiples of 3 or 5
        /// -------------------------------------------------------------------
        /// If we list all the natural numbers below 10 that are multiples of
        /// 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        /// Find the sum of all the multiples of 3 or 5 below 1000.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #1</returns>
        public long SolveProblem0001()
        {
            long sum = 0;
            for (long i = 1; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    sum += i;
                }
            }
            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 2
        /// Even Fibonacci numbers
        /// -------------------------------------------------------------------
        /// Each new term in the Fibonacci sequence is generated by adding the
        /// previous two terms. By starting with 1 and 2, the first 10 terms
        /// will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        /// By considering the terms in the Fibonacci sequence whose values do
        /// not exceed four million, find the sum of the even-valued terms.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #2</returns>
        public long SolveProblem0002()
        {
            long sum = 0;
            long previousValue1 = 0;
            long previousValue2 = 1;
            long currentValue = previousValue1 + previousValue2;

            while (currentValue < 4000000)
            {
                if (currentValue % 2 == 0)
                {
                    sum += currentValue;
                }

                previousValue1 = previousValue2;
                previousValue2 = currentValue;
                currentValue = previousValue1 + previousValue2;
            }

            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 3
        /// Largest prime factor
        /// -------------------------------------------------------------------
        /// The prime factors of 13195 are 5, 7, 13 and 29.
        /// What is the largest prime factor of the number 600851475143 ?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #3</returns>
        public long SolveProblem0003()
        {
            long number = 600851475143;

            // Strategy:

            // PART 1 => start from 2 until M, where M << K (e.g. M = 10000)
            //           until we hit a number N <= M for which K is divisible
            //           if M is hit, then use N = M.

            // PART 2 => now that we have N as the smallest number for which
            //           K is visible, then we can search now from K/N until N
            //           until we get a N < T < K/N value that will be the
            //           greatest number for which K is visible.

            // Note that below N and above K/N it is proved that there are no
            // numbers for which K will be divisible, therefore, it is the
            // shortest interval we can use for the search.

            // Optimization notes:
            // #1 - The number is odd, therefore, is not divisible by any even number.
            // #2 - The number is does not end in 0 or 5, therefore, is not divisible by any number ending in 0 or 5.
            // #3 - The number is not divisible by 3, therefore, not divisible by any multiple of 3.

            // #########################
            // ### STRATEGY - PART 1 ###
            // #########################

            // Why 7? See Hints #1, #2, #3.
            long minorDivisibleNumber = 7;
            long stopAt = 10000;
            while (number % minorDivisibleNumber != 0 && minorDivisibleNumber <= stopAt)
            {
                // Why +2? See Hint #1. 
                minorDivisibleNumber = minorDivisibleNumber + 2;
            }
            // DEBUG
            // System.Console.WriteLine($"Stopped at: {minorDivisibleNumber}. ");


            // #########################
            // ### STRATEGY - PART 2 ###
            // #########################

            long currentTentative = number / minorDivisibleNumber;

            // Why %2? See Hint #1.
            currentTentative = (currentTentative % 2 == 0 ? currentTentative-- : currentTentative);

            // Why skipFives? See Hint #2.
            long skipFives = currentTentative % 5;
            if (skipFives == 0)
            {
                currentTentative = currentTentative - 2;
                skipFives = 4;
            }
            else
            {
                // We are "converting" the mod 5 to a sequence from
                // 4 to 0 such that when reaching 0, skils the number
                // because it currently ends in 5. Yeah, cumbersome,
                // but it is a 20% improvement in the speed.
                if (skipFives == 1) skipFives = 3;
                else if (skipFives == 2) skipFives = 1;
                else if (skipFives == 3) skipFives = 4;
                else if (skipFives == 4) skipFives = 2;
            }

            // DEBUG
            // var watch = new System.Diagnostics.Stopwatch();
            // watch.Start();
            // long iterations = 0;
            // long count = 0;
            // long step = 100000000;

            // Worst case, we reach 1.
            // That is guaranteed to cause the cycle to stop.
            while (number % currentTentative != 0 || !Utils.IsPrime(currentTentative))
            {
                // Why -2? See Hint #1.
                currentTentative = currentTentative - 2;

                // Why skipFives? See Hint #2.
                skipFives = skipFives - 1;
                if (skipFives == 0)
                {
                    currentTentative = currentTentative - 2;
                    skipFives = 4;
                }

                // DEBUG
                // if (++iterations > step)
                // {
                //     iterations = 0;
                //     count += step;
                //     System.Console.WriteLine($"So far: {count} iterations, reached number {currentTentative} in {watch.ElapsedMilliseconds / 1000} s. ");
                // }
            }

            // DEBUG
            // watch.Stop();

            return currentTentative;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 4
        /// Largest palindrome product
        /// -------------------------------------------------------------------
        /// A palindromic number reads the same both ways.  The largest
        /// palindrome made from the product of two 2-digit numbers is
        /// 9009 = 91 × 99. Find the largest palindrome made from the product
        /// of two 3-digit numbers.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #4</returns>
        public long SolveProblem0004()
        {
            long largestPalindromeSoFar = 0;
            long currentProduct = 0;

            for (int i = 999; i >= 100; i--)
            {
                for (int j = 999; j >= 100; j--)
                {
                    currentProduct = i * j;
                    if (currentProduct > largestPalindromeSoFar && Utils.IsPalindrome(currentProduct))
                    {
                        largestPalindromeSoFar = currentProduct;
                    }
                }
            }

            return largestPalindromeSoFar;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 5
        /// Smallest multiple
        /// -------------------------------------------------------------------
        /// 2520 is the smallest number that can be divided by each of the
        /// numbers from 1 to 10 without any remainder.
        /// What is the smallest positive number that is evenly divisible by
        /// all of the numbers from 1 to 20?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #5</returns>
        public long SolveProblem0005()
        {
            // STRATEGY:
            // - Search one mod at a time: first smallest number with mod 1 == 0,
            //   then mod 2, then mod 3 ... until mod 20.
            // - Step by the last smallest number, because e.g. if we have the
            //   smallest number with mod 5, then only multiples of that
            //   smallest number will be divisible by all numbers from 1 to 5.

            // Note that we could start with:
            //      long currentMinimum = 2520;
            //      long currentModule = 11;
            // ... as we already those values from the problem description,
            // but this way the code is more generic.

            long targetModule = 20;
            long currentModule = 1;
            long currentMinimum = 1;
            long currentStep = currentMinimum;

            while (currentModule <= targetModule)
            {
                if (currentMinimum % currentModule == 0)
                {
                    currentStep = currentMinimum;
                    currentModule++;
                }
                else
                {
                    currentMinimum += currentStep;
                }
            }

            return currentMinimum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 6
        /// Sum square difference
        /// -------------------------------------------------------------------
        /// The sum of the squares of the first ten natural numbers is:
        ///    1*1 + 2*2 + ... + 10*10 = 385
        ///    
        /// The square of the sum of the first ten natural numbers is:
        ///    (1+2+...+10)^2 = 55^2 = 2640
        ///    
        /// Hence the difference between the sum of the squares of the first
        /// ten natural numbers and the square of the sum is:
        ///        3025 - 385 = 2640
        ///    
        /// Find the difference between the sum of the squares of the first
        /// one hundred natural numbers and the square of the sum.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #6</returns>
        public long SolveProblem0006()
        {
            long targetNumber = 100;
            long squaresSum = 0;
            long simpleSum = 0;

            for (long i = 1; i <= targetNumber; i++)
            {
                squaresSum += i * i;
                simpleSum += i;
            }

            return (simpleSum * simpleSum) - squaresSum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 7
        /// 10001st prime
        /// -------------------------------------------------------------------
        /// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
        /// we can see that the 6th prime is 13.
        /// What is the 10 001st prime number?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #7</returns>
        public long SolveProblem0007()
        {
            // Optimization Hints:
            // #1 - No odd numbers (all are divisible by 2)
            // #2 - No numbers ending in 5 (all are divisible by 5)
            //      (note: no need to use hint #2, fast enough)

            long primeCount = 1;
            long targetCount = 10001;
            long currentPrime = 2;
            long currentNumber = currentPrime + 1;

            while (primeCount < targetCount)
            {
                if (Utils.IsPrime(currentNumber))
                {
                    currentPrime = currentNumber;
                    primeCount++;
                }

                // Why 2? See Hint #1.
                currentNumber = currentNumber + 2;
            }

            return currentPrime;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 8
        /// Largest product in a series
        /// -------------------------------------------------------------------
        /// The four adjacent digits in the 1000-digit number that have the
        /// greatest product are 9 × 9 × 8 × 9 = 5832.
        /// 
        /// 73167176531330624919225119674426574742355349194934
        /// 96983520312774506326239578318016984801869478851843
        /// 85861560789112949495459501737958331952853208805511
        /// 12540698747158523863050715693290963295227443043557
        /// 66896648950445244523161731856403098711121722383113
        /// 62229893423380308135336276614282806444486645238749
        /// 30358907296290491560440772390713810515859307960866
        /// 70172427121883998797908792274921901699720888093776
        /// 65727333001053367881220235421809751254540594752243
        /// 52584907711670556013604839586446706324415722155397
        /// 53697817977846174064955149290862569321978468622482
        /// 83972241375657056057490261407972968652414535100474
        /// 82166370484403199890008895243450658541227588666881
        /// 16427171479924442928230863465674813919123162824586
        /// 17866458359124566529476545682848912883142607690042
        /// 24219022671055626321111109370544217506941658960408
        /// 07198403850962455444362981230987879927244284909188
        /// 84580156166097919133875499200524063689912560717606
        /// 05886116467109405077541002256983155200055935729725
        /// 71636269561882670428252483600823257530420752963450
        /// 
        /// Find the thirteen adjacent digits in the 1000-digit number that
        /// have the greatest product. What is the value of this product?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #8</returns>
        public long SolveProblem0008()
        {
            string bigNumber = "73167176531330624919225119674426574742355349194934"
                             + "96983520312774506326239578318016984801869478851843"
                             + "85861560789112949495459501737958331952853208805511"
                             + "12540698747158523863050715693290963295227443043557"
                             + "66896648950445244523161731856403098711121722383113"
                             + "62229893423380308135336276614282806444486645238749"
                             + "30358907296290491560440772390713810515859307960866"
                             + "70172427121883998797908792274921901699720888093776"
                             + "65727333001053367881220235421809751254540594752243"
                             + "52584907711670556013604839586446706324415722155397"
                             + "53697817977846174064955149290862569321978468622482"
                             + "83972241375657056057490261407972968652414535100474"
                             + "82166370484403199890008895243450658541227588666881"
                             + "16427171479924442928230863465674813919123162824586"
                             + "17866458359124566529476545682848912883142607690042"
                             + "24219022671055626321111109370544217506941658960408"
                             + "07198403850962455444362981230987879927244284909188"
                             + "84580156166097919133875499200524063689912560717606"
                             + "05886116467109405077541002256983155200055935729725"
                             + "71636269561882670428252483600823257530420752963450";

            int targetSequence = 13;
            long currentGreatestProduct = 0;

            for (int i = 0; i < bigNumber.Length - targetSequence; i++)
            {
                string extract = bigNumber.Substring(i, targetSequence);

                // Optimization hint: if there is a zero, the product will be zero.
                // therefore, ignore this sequence, and go for the next one.
                if (extract.Contains("0"))
                {
                    continue;
                }

                long product = 1;
                foreach (char c in extract)
                {
                    // Convert char to number by subtracting to it the ASCII value of '0'.
                    product *= (c - '0');
                }

                if (product > currentGreatestProduct)
                {
                    currentGreatestProduct = product;
                }
            }

            return currentGreatestProduct;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 9
        /// Special Pythagorean triplet
        /// -------------------------------------------------------------------
        /// A Pythagorean triplet is a set of three natural numbers, a < b < c,
        /// for which:
        ///        a^2 + b^2 = c^2
        ///        
        /// For example:
        ///        3^2 + 4^2 = 9 + 16 = 25 = 5^2.
        ///        
        /// There exists exactly one Pythagorean triplet for which:
        ///        a + b + c = 1000.
        ///        
        /// Find the product abc.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #9</returns>
        public long SolveProblem0009()
        {
            int targetSum = 1000;

            for (int a = 1; a < 1000; a++)
            {
                for (int b = 1; b < 1000; b++)
                {
                    for (int c = 1; c < 1000; c++)
                    {
                        if (a * a + b * b == c * c)
                        {
                            if (a + b + c == targetSum)
                            {
                                return a * b * c;
                            }
                        }

                    }
                }
            }

            return -1;
        }
    }
}