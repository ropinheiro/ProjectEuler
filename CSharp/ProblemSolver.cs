using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System;

namespace ProjectEuler
{
    public class ProblemSolver
    {
        /// <summary>
        /// Set this to true if you want to skip problems whose solution is slow to calculate.
        /// Useful if you want to focus in your current problem without commenting a lot of stuff.
        /// </summary>
        const bool SkipSlow = false;

        public ProblemSolver()
        {
            // ## BEGIN OF HACK ##
            // "Waste" here the time with the reflection overload happening
            // in the 1st time we call the invoker, so that we do not affect
            // the measured time of the 1st problem with extra milliseconds.
            InvokeSolverMethod(1);
            // ## END OF HACK ##
        }

        /// <summary>
        /// Get the number or problems solved so far.
        /// </summary>
        /// <returns>The number of methods with "SolveProblem" in the name.</returns>
        public int NumberOfProblemsSolved
        {
            get
            {
                if (_numberOfProblemsSolved == -1)
                {
                    _numberOfProblemsSolved = this
                        .GetType()
                        .GetMethods()
                        .Where(m => m.Name.Contains("SolveProblem"))
                        .Count();
                }
                return _numberOfProblemsSolved;
            }
        }
        private int _numberOfProblemsSolved = -1;

        /// <summary>
        /// Solve a problem, calculating the time it takes to execute.
        /// </summary>
        /// <param name="problem">A given problem number to solve.</param>
        /// <returns>The solution to the problem, including execution metrics.</returns>
        public SolutionInfo Solve(ProblemInfo problem)
        {
            if (problem.HasSlowResolution && SkipSlow == true)
            {
                return SolutionInfo.GetSkippedSolution(problem.Number);
            }

            SolutionInfo solution = new SolutionInfo(problem.Number);

            var watch = new System.Diagnostics.Stopwatch();
            watch.Start();
            solution.ProblemSolution = InvokeSolverMethod(problem.Number);
            watch.Stop();

            solution.ExecutionTimeInMs = watch.ElapsedMilliseconds;
            solution.Skipped = false;
            solution.SolutionIsCorrect = (solution.ProblemSolution == problem.ExpectedSolution);

            return solution;
        }

        /// <summary>
        /// Runs the problem solver's method given a problem number.
        /// Expects that there is a method with name "SolveProblemXXXX",
        /// where XXXX is the problem number left padded with zeros.
        /// </summary>
        /// <param name="problemNumber">A given problem number.</param>
        /// <returns>The solution of the problem.</returns>
        private long InvokeSolverMethod(int problemNumber)
        {
            MethodInfo solverMethod = this
                .GetType()
                .GetMethod($"SolveProblem{problemNumber.ToString().PadLeft(4, '0')}");

            return (long)solverMethod.Invoke(this, null);
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 1
        /// Multiples of 3 or 5
        /// -------------------------------------------------------------------
        /// If we list all the natural numbers below 10 that are multiples of
        /// 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        /// Find the sum of all the multiples of 3 or 5 below 1000.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #1</returns>
        public long SolveProblem0001()
        {
            long sum = 0;
            for (long i = 1; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    sum += i;
                }
            }
            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 2
        /// Even Fibonacci numbers
        /// -------------------------------------------------------------------
        /// Each new term in the Fibonacci sequence is generated by adding the
        /// previous two terms. By starting with 1 and 2, the first 10 terms
        /// will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        /// By considering the terms in the Fibonacci sequence whose values do
        /// not exceed four million, find the sum of the even-valued terms.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #2</returns>
        public long SolveProblem0002()
        {
            long sum = 0;
            long previousValue1 = 0;
            long previousValue2 = 1;
            long currentValue = previousValue1 + previousValue2;

            while (currentValue < 4000000)
            {
                if (currentValue % 2 == 0)
                {
                    sum += currentValue;
                }

                previousValue1 = previousValue2;
                previousValue2 = currentValue;
                currentValue = previousValue1 + previousValue2;
            }

            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 3
        /// Largest prime factor
        /// -------------------------------------------------------------------
        /// The prime factors of 13195 are 5, 7, 13 and 29.
        /// What is the largest prime factor of the number 600851475143 ?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #3</returns>
        public long SolveProblem0003()
        {
            long number = 600851475143;

            // Strategy:

            // PART 1 => start from 2 until M, where M << K (e.g. M = 10000)
            //           until we hit a number N <= M for which K is divisible
            //           if M is hit, then use N = M.

            // PART 2 => now that we have N as the smallest number for which
            //           K is visible, then we can search now from K/N until N
            //           until we get a N < T < K/N value that will be the
            //           greatest number for which K is visible.

            // Note that below N and above K/N it is proved that there are no
            // numbers for which K will be divisible, therefore, it is the
            // shortest interval we can use for the search.

            // Optimization notes:
            // #1 - The number is odd, therefore, is not divisible by any even number.
            // #2 - The number is does not end in 0 or 5, therefore, is not divisible by any number ending in 0 or 5.
            // #3 - The number is not divisible by 3, therefore, not divisible by any multiple of 3.

            // #########################
            // ### STRATEGY - PART 1 ###
            // #########################

            // Why 7? See Hints #1, #2, #3.
            long minorDivisibleNumber = 7;
            long stopAt = 10000;
            while (number % minorDivisibleNumber != 0 && minorDivisibleNumber <= stopAt)
            {
                // Why +2? See Hint #1. 
                minorDivisibleNumber = minorDivisibleNumber + 2;
            }
            // DEBUG
            // System.Console.WriteLine($"Stopped at: {minorDivisibleNumber}. ");


            // #########################
            // ### STRATEGY - PART 2 ###
            // #########################

            long currentTentative = number / minorDivisibleNumber;

            // Why %2? See Hint #1.
            currentTentative = (currentTentative % 2 == 0 ? currentTentative-- : currentTentative);

            // Why skipFives? See Hint #2.
            long skipFives = currentTentative % 5;
            if (skipFives == 0)
            {
                currentTentative = currentTentative - 2;
                skipFives = 4;
            }
            else
            {
                // We are "converting" the mod 5 to a sequence from
                // 4 to 0 such that when reaching 0, skils the number
                // because it currently ends in 5. Yeah, cumbersome,
                // but it is a 20% improvement in the speed.
                if (skipFives == 1) skipFives = 3;
                else if (skipFives == 2) skipFives = 1;
                else if (skipFives == 3) skipFives = 4;
                else if (skipFives == 4) skipFives = 2;
            }

            // DEBUG
            // var watch = new System.Diagnostics.Stopwatch();
            // watch.Start();
            // long iterations = 0;
            // long count = 0;
            // long step = 100000000;

            // Worst case, we reach 1.
            // That is guaranteed to cause the cycle to stop.
            while (number % currentTentative != 0 || !Utils.IsPrime(currentTentative))
            {
                // Why -2? See Hint #1.
                currentTentative = currentTentative - 2;

                // Why skipFives? See Hint #2.
                skipFives = skipFives - 1;
                if (skipFives == 0)
                {
                    currentTentative = currentTentative - 2;
                    skipFives = 4;
                }

                // DEBUG
                // if (++iterations > step)
                // {
                //     iterations = 0;
                //     count += step;
                //     System.Console.WriteLine($"So far: {count} iterations, reached number {currentTentative} in {watch.ElapsedMilliseconds / 1000} s. ");
                // }
            }

            // DEBUG
            // watch.Stop();

            return currentTentative;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 4
        /// Largest palindrome product
        /// -------------------------------------------------------------------
        /// A palindromic number reads the same both ways.  The largest
        /// palindrome made from the product of two 2-digit numbers is
        /// 9009 = 91 × 99. Find the largest palindrome made from the product
        /// of two 3-digit numbers.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #4</returns>
        public long SolveProblem0004()
        {
            long largestPalindromeSoFar = 0;
            long currentProduct = 0;

            for (int i = 999; i >= 100; i--)
            {
                for (int j = 999; j >= 100; j--)
                {
                    currentProduct = i * j;
                    if (currentProduct > largestPalindromeSoFar && Utils.IsPalindrome(currentProduct))
                    {
                        largestPalindromeSoFar = currentProduct;
                    }
                }
            }

            return largestPalindromeSoFar;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 5
        /// Smallest multiple
        /// -------------------------------------------------------------------
        /// 2520 is the smallest number that can be divided by each of the
        /// numbers from 1 to 10 without any remainder.
        /// What is the smallest positive number that is evenly divisible by
        /// all of the numbers from 1 to 20?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #5</returns>
        public long SolveProblem0005()
        {
            // STRATEGY:
            // - Search one mod at a time: first smallest number with mod 1 == 0,
            //   then mod 2, then mod 3 ... until mod 20.
            // - Step by the last smallest number, because e.g. if we have the
            //   smallest number with mod 5, then only multiples of that
            //   smallest number will be divisible by all numbers from 1 to 5.

            // Note that we could start with:
            //      long currentMinimum = 2520;
            //      long currentModule = 11;
            // ... as we already those values from the problem description,
            // but this way the code is more generic.

            long targetModule = 20;
            long currentModule = 1;
            long currentMinimum = 1;
            long currentStep = currentMinimum;

            while (currentModule <= targetModule)
            {
                if (currentMinimum % currentModule == 0)
                {
                    currentStep = currentMinimum;
                    currentModule++;
                }
                else
                {
                    currentMinimum += currentStep;
                }
            }

            return currentMinimum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 6
        /// Sum square difference
        /// -------------------------------------------------------------------
        /// The sum of the squares of the first ten natural numbers is:
        ///    1*1 + 2*2 + ... + 10*10 = 385
        ///    
        /// The square of the sum of the first ten natural numbers is:
        ///    (1+2+...+10)^2 = 55^2 = 2640
        ///    
        /// Hence the difference between the sum of the squares of the first
        /// ten natural numbers and the square of the sum is:
        ///        3025 - 385 = 2640
        ///    
        /// Find the difference between the sum of the squares of the first
        /// one hundred natural numbers and the square of the sum.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #6</returns>
        public long SolveProblem0006()
        {
            long targetNumber = 100;
            long squaresSum = 0;
            long simpleSum = 0;

            for (long i = 1; i <= targetNumber; i++)
            {
                squaresSum += i * i;
                simpleSum += i;
            }

            return (simpleSum * simpleSum) - squaresSum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 7
        /// 10001st prime
        /// -------------------------------------------------------------------
        /// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
        /// we can see that the 6th prime is 13.
        /// What is the 10 001st prime number?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #7</returns>
        public long SolveProblem0007()
        {
            // Optimization Hints:
            // #1 - No odd numbers (all are divisible by 2)
            // #2 - No numbers ending in 5 (all are divisible by 5)
            //      (note: no need to use hint #2, fast enough)

            long primeCount = 1;
            long targetCount = 10001;
            long currentPrime = 2;
            long currentNumber = currentPrime + 1;

            while (primeCount < targetCount)
            {
                if (Utils.IsPrime(currentNumber))
                {
                    currentPrime = currentNumber;
                    primeCount++;
                }

                // Why 2? See Hint #1.
                currentNumber = currentNumber + 2;
            }

            return currentPrime;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 8
        /// Largest product in a series
        /// -------------------------------------------------------------------
        /// The four adjacent digits in the 1000-digit number that have the
        /// greatest product are 9 × 9 × 8 × 9 = 5832.
        /// 
        /// 73167176531330624919225119674426574742355349194934
        /// 96983520312774506326239578318016984801869478851843
        /// 85861560789112949495459501737958331952853208805511
        /// 12540698747158523863050715693290963295227443043557
        /// 66896648950445244523161731856403098711121722383113
        /// 62229893423380308135336276614282806444486645238749
        /// 30358907296290491560440772390713810515859307960866
        /// 70172427121883998797908792274921901699720888093776
        /// 65727333001053367881220235421809751254540594752243
        /// 52584907711670556013604839586446706324415722155397
        /// 53697817977846174064955149290862569321978468622482
        /// 83972241375657056057490261407972968652414535100474
        /// 82166370484403199890008895243450658541227588666881
        /// 16427171479924442928230863465674813919123162824586
        /// 17866458359124566529476545682848912883142607690042
        /// 24219022671055626321111109370544217506941658960408
        /// 07198403850962455444362981230987879927244284909188
        /// 84580156166097919133875499200524063689912560717606
        /// 05886116467109405077541002256983155200055935729725
        /// 71636269561882670428252483600823257530420752963450
        /// 
        /// Find the thirteen adjacent digits in the 1000-digit number that
        /// have the greatest product. What is the value of this product?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #8</returns>
        public long SolveProblem0008()
        {
            string bigNumber = "73167176531330624919225119674426574742355349194934"
                             + "96983520312774506326239578318016984801869478851843"
                             + "85861560789112949495459501737958331952853208805511"
                             + "12540698747158523863050715693290963295227443043557"
                             + "66896648950445244523161731856403098711121722383113"
                             + "62229893423380308135336276614282806444486645238749"
                             + "30358907296290491560440772390713810515859307960866"
                             + "70172427121883998797908792274921901699720888093776"
                             + "65727333001053367881220235421809751254540594752243"
                             + "52584907711670556013604839586446706324415722155397"
                             + "53697817977846174064955149290862569321978468622482"
                             + "83972241375657056057490261407972968652414535100474"
                             + "82166370484403199890008895243450658541227588666881"
                             + "16427171479924442928230863465674813919123162824586"
                             + "17866458359124566529476545682848912883142607690042"
                             + "24219022671055626321111109370544217506941658960408"
                             + "07198403850962455444362981230987879927244284909188"
                             + "84580156166097919133875499200524063689912560717606"
                             + "05886116467109405077541002256983155200055935729725"
                             + "71636269561882670428252483600823257530420752963450";

            int targetSequence = 13;
            long currentGreatestProduct = 0;

            for (int i = 0; i < bigNumber.Length - targetSequence; i++)
            {
                string extract = bigNumber.Substring(i, targetSequence);

                // Optimization hint: if there is a zero, the product will be zero.
                // therefore, ignore this sequence, and go for the next one.
                if (extract.Contains("0"))
                {
                    continue;
                }

                long product = 1;
                foreach (char c in extract)
                {
                    // Convert char to number by subtracting to it the ASCII value of '0'.
                    product *= (c - '0');
                }

                if (product > currentGreatestProduct)
                {
                    currentGreatestProduct = product;
                }
            }

            return currentGreatestProduct;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 9
        /// Special Pythagorean triplet
        /// -------------------------------------------------------------------
        /// A Pythagorean triplet is a set of three natural numbers, a < b < c,
        /// for which:
        ///        a^2 + b^2 = c^2
        ///        
        /// For example:
        ///        3^2 + 4^2 = 9 + 16 = 25 = 5^2.
        ///        
        /// There exists exactly one Pythagorean triplet for which:
        ///        a + b + c = 1000.
        ///        
        /// Find the product abc.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #9</returns>
        public long SolveProblem0009()
        {
            int targetSum = 1000;

            for (int a = 1; a < 1000; a++)
            {
                for (int b = 1; b < 1000; b++)
                {
                    for (int c = 1; c < 1000; c++)
                    {
                        if (a * a + b * b == c * c)
                        {
                            if (a + b + c == targetSum)
                            {
                                return a * b * c;
                            }
                        }

                    }
                }
            }

            return -1;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 10
        /// Summation of primes
        /// -------------------------------------------------------------------
        /// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
        /// Find the sum of all the primes below two million.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #10</returns>
        public long SolveProblem0010()
        {
            long targetPrimeNumber = 2000000;
            long sum = 0;

            for (long i = 2; i < targetPrimeNumber; i++)
            {
                if (Utils.IsPrime(i))
                {
                    sum += i;
                }
            }

            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 11
        /// Largest product in a grid
        /// -------------------------------------------------------------------
        /// In the 20×20 grid below, four numbers along a diagonal line have
        /// been marked in red [Note: I used *xx* here, instead].
        /// 
        /// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
        /// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
        /// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
        /// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
        /// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
        /// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
        /// 32 98 81 28 64 23 67 10 *26* 38 40 67 59 54 70 66 18 38 64 70
        /// 67 26 20 68 02 62 12 20 95 *63* 94 39 63 08 40 91 66 49 94 21
        /// 24 55 58 05 66 73 99 26 97 17 *78* 78 96 83 14 88 34 89 63 72
        /// 21 36 23 09 75 00 76 44 20 45 35 *14* 00 61 33 97 34 31 33 95
        /// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
        /// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
        /// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
        /// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
        /// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
        /// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
        /// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
        /// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
        /// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
        /// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
        /// 
        /// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
        /// What is the greatest product of four adjacent numbers in the
        /// same direction (up, down, left, right, or diagonally) in the
        /// 20×20 grid?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #11</returns>
        public long SolveProblem0011()
        {
            // Strategy:
            // 1. Create an array with the numbers
            // 2. Make 2 nested cycles from 0 to N-4 in both directions
            // 3. In each step we get a square of 4x4 to check
            // 4. Nested cycle to check ortogonal rows
            // 5. Simple cycle to check diagonal rows

            int targetNumberCount = 4;
            long greatestProduct = 0;

            // 1. Create an array with the numbers
            int[,] array = new int[,]
            {
                { 08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08 },
                { 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00 },
                { 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65 },
                { 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91 },
                { 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80 },
                { 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50 },
                { 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70 },
                { 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21 },
                { 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72 },
                { 21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95 },
                { 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92 },
                { 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57 },
                { 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58 },
                { 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40 },
                { 04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66 },
                { 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69 },
                { 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36 },
                { 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16 },
                { 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54 },
                { 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48 }
            };

            // 2. Make 2 nested cycles from 0 to N-targetNumberCount in both directions
            for (int i = 0; i < array.GetLength(0) - targetNumberCount; i++)
            {
                // 3. In each step we get a square of targetNumberCount x targetNumberCount to check
                for (int j = 0; j < array.GetLength(1) - targetNumberCount; j++)
                {
                    // 4. Nested cycle to check ortogonal rows
                    for (int a = 0; a < targetNumberCount; a++)
                    {
                        long rowProduct = 1;
                        long columnProduct = 1;
                        for (int b = 0; b < targetNumberCount; b++)
                        {
                            rowProduct *= array[i + a, j + b];
                            columnProduct *= array[i + b, j + a];
                        }
                        if (rowProduct > greatestProduct)
                        {
                            greatestProduct = rowProduct;
                        }
                        if (columnProduct > greatestProduct)
                        {
                            greatestProduct = columnProduct;
                        }
                    }

                    // 5. Simple cycle to check diagonal rows
                    long backslashProduct = 1;
                    long forwardslashProduct = 1;
                    for (int s = 0; s < targetNumberCount; s++)
                    {
                        backslashProduct *= array[i + s, j + s];
                        forwardslashProduct *= array[i + targetNumberCount - 1 - s, j + s];
                    }
                    if (backslashProduct > greatestProduct)
                    {
                        greatestProduct = backslashProduct;
                    }
                    if (forwardslashProduct > greatestProduct)
                    {
                        greatestProduct = forwardslashProduct;
                    }

                }
            }

            return greatestProduct;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 12
        /// Highly divisible triangular number
        /// -------------------------------------------------------------------
        /// The sequence of triangle numbers is generated by adding the natural
        /// numbers. So the 7th triangle number would be:
        ///          1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
        ///
        /// The first ten terms would be:
        ///          1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        /// 
        /// Let us list the factors of the first seven triangle numbers:
        ///  1: 1
        ///  3: 1, 3
        ///  6: 1, 2, 3, 6
        /// 10: 1, 2, 5, 10
        /// 15: 1, 3, 5, 15
        /// 21: 1, 3, 7, 21
        /// 28: 1, 2, 4, 7, 14, 28
        /// 
        /// We can see that 28 is the first triangle number to have over
        /// five divisors. What is the value of the first triangle number
        /// to have over five hundred divisors?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #12</returns>
        public long SolveProblem0012()
        {
            long targetDivisorCount = 500;

            long currentTriangle = 0;
            for (long x = 1; x < long.MaxValue; x++)
            {
                // Just accumulate, no need to recalculate sums from 1 all the time.
                currentTriangle += x;

                // We always start counting 2: the 1 and the currentTriangle itself.
                int divisorsCount = 2;
                long currentDivisor = 2;
                long maxDivisorToTest = (long)Math.Sqrt(currentTriangle);
                while (currentDivisor <= maxDivisorToTest)
                {
                    if (currentTriangle % currentDivisor == 0)
                    {
                        divisorsCount++;

                        // Now that we found a smaller divisor A, we have also
                        // a larger divisor B such that AxB=currentTriangle.
                        long otherDivisor = currentTriangle / currentDivisor;

                        // Of course we do not want to count it twice if we
                        // happen to find the square root of currentTriangle!
                        if (currentDivisor != otherDivisor)
                        {
                            divisorsCount++;
                        }
                    }

                    if (divisorsCount >= targetDivisorCount)
                    {
                        return currentTriangle;
                    }

                    currentDivisor++;
                }
            }

            // Oops... not found?
            return -1;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 13
        /// Large sum
        /// -------------------------------------------------------------------
        /// Work out the first ten digits of the sum of the following
        /// one-hundred 50-digit numbers.
        /// 
        ///      37107287533902102798797998220837590246510135740250 (...)
        ///            [see below for the complete number list] 
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #13</returns>
        public long SolveProblem0013()
        {
            // Strategy:
            // 1. 50-digit numbers do not fit in a long.
            //    A long has a maximum of 19 digits.
            // 2. We will use an array of K longs for each 10-digit part.
            //    Imagine K=3. Then each part will be responsible for:
            //    sums[0] -> xxxxxxxxxx xxxxxxxxxx 0000000000 to xxxxxxxxxx xxxxxxxxxx 9999999999
            //    sums[1] -> xxxxxxxxxx 0000000000 xxxxxxxxxx to xxxxxxxxxx 9999999999 xxxxxxxxxx
            //    sums[2] -> 0000000000 xxxxxxxxxx xxxxxxxxxx to 9999999999 xxxxxxxxxx xxxxxxxxxx
            // 3. We could try not to force some maximum K. But mathematically
            //    we know that adding 50-digit numbers 100 times will need
            //    at least K=6 (imagine 50-digit numbers all 9's, times 100.
            //    the result will be a 52-digit number with 50 9's and 2 0's).
            // 4. When doing sums, we first sum the last 10 digits, then the
            //    sum will be either 10 or 11 digits. Fill part[0] with the
            //    last 10 digits. If we have a 11th digit, sum it with the
            //    next 10-digit pair, and so on, until we reach the most
            //    significant digits of each number pair.

            int targetFirstDigitCount = 10;
            int sumParts = 6;  // number of parts we will consider for the sum.
            int partSize = 10; // number of digits in each part.

            string[] numbers = new string[]
            {
                "37107287533902102798797998220837590246510135740250",
                "46376937677490009712648124896970078050417018260538",
                "74324986199524741059474233309513058123726617309629",
                "91942213363574161572522430563301811072406154908250",
                "23067588207539346171171980310421047513778063246676",
                "89261670696623633820136378418383684178734361726757",
                "28112879812849979408065481931592621691275889832738",
                "44274228917432520321923589422876796487670272189318",
                "47451445736001306439091167216856844588711603153276",
                "70386486105843025439939619828917593665686757934951",
                "62176457141856560629502157223196586755079324193331",
                "64906352462741904929101432445813822663347944758178",
                "92575867718337217661963751590579239728245598838407",
                "58203565325359399008402633568948830189458628227828",
                "80181199384826282014278194139940567587151170094390",
                "35398664372827112653829987240784473053190104293586",
                "86515506006295864861532075273371959191420517255829",
                "71693888707715466499115593487603532921714970056938",
                "54370070576826684624621495650076471787294438377604",
                "53282654108756828443191190634694037855217779295145",
                "36123272525000296071075082563815656710885258350721",
                "45876576172410976447339110607218265236877223636045",
                "17423706905851860660448207621209813287860733969412",
                "81142660418086830619328460811191061556940512689692",
                "51934325451728388641918047049293215058642563049483",
                "62467221648435076201727918039944693004732956340691",
                "15732444386908125794514089057706229429197107928209",
                "55037687525678773091862540744969844508330393682126",
                "18336384825330154686196124348767681297534375946515",
                "80386287592878490201521685554828717201219257766954",
                "78182833757993103614740356856449095527097864797581",
                "16726320100436897842553539920931837441497806860984",
                "48403098129077791799088218795327364475675590848030",
                "87086987551392711854517078544161852424320693150332",
                "59959406895756536782107074926966537676326235447210",
                "69793950679652694742597709739166693763042633987085",
                "41052684708299085211399427365734116182760315001271",
                "65378607361501080857009149939512557028198746004375",
                "35829035317434717326932123578154982629742552737307",
                "94953759765105305946966067683156574377167401875275",
                "88902802571733229619176668713819931811048770190271",
                "25267680276078003013678680992525463401061632866526",
                "36270218540497705585629946580636237993140746255962",
                "24074486908231174977792365466257246923322810917141",
                "91430288197103288597806669760892938638285025333403",
                "34413065578016127815921815005561868836468420090470",
                "23053081172816430487623791969842487255036638784583",
                "11487696932154902810424020138335124462181441773470",
                "63783299490636259666498587618221225225512486764533",
                "67720186971698544312419572409913959008952310058822",
                "95548255300263520781532296796249481641953868218774",
                "76085327132285723110424803456124867697064507995236",
                "37774242535411291684276865538926205024910326572967",
                "23701913275725675285653248258265463092207058596522",
                "29798860272258331913126375147341994889534765745501",
                "18495701454879288984856827726077713721403798879715",
                "38298203783031473527721580348144513491373226651381",
                "34829543829199918180278916522431027392251122869539",
                "40957953066405232632538044100059654939159879593635",
                "29746152185502371307642255121183693803580388584903",
                "41698116222072977186158236678424689157993532961922",
                "62467957194401269043877107275048102390895523597457",
                "23189706772547915061505504953922979530901129967519",
                "86188088225875314529584099251203829009407770775672",
                "11306739708304724483816533873502340845647058077308",
                "82959174767140363198008187129011875491310547126581",
                "97623331044818386269515456334926366572897563400500",
                "42846280183517070527831839425882145521227251250327",
                "55121603546981200581762165212827652751691296897789",
                "32238195734329339946437501907836945765883352399886",
                "75506164965184775180738168837861091527357929701337",
                "62177842752192623401942399639168044983993173312731",
                "32924185707147349566916674687634660915035914677504",
                "99518671430235219628894890102423325116913619626622",
                "73267460800591547471830798392868535206946944540724",
                "76841822524674417161514036427982273348055556214818",
                "97142617910342598647204516893989422179826088076852",
                "87783646182799346313767754307809363333018982642090",
                "10848802521674670883215120185883543223812876952786",
                "71329612474782464538636993009049310363619763878039",
                "62184073572399794223406235393808339651327408011116",
                "66627891981488087797941876876144230030984490851411",
                "60661826293682836764744779239180335110989069790714",
                "85786944089552990653640447425576083659976645795096",
                "66024396409905389607120198219976047599490197230297",
                "64913982680032973156037120041377903785566085089252",
                "16730939319872750275468906903707539413042652315011",
                "94809377245048795150954100921645863754710598436791",
                "78639167021187492431995700641917969777599028300699",
                "15368713711936614952811305876380278410754449733078",
                "40789923115535562561142322423255033685442488917353",
                "44889911501440648020369068063960672322193204149535",
                "41503128880339536053299340368006977710650566631954",
                "81234880673210146739058568557934581403627822703280",
                "82616570773948327592232845941706525094512325230608",
                "22918802058777319719839450180888072429661980811197",
                "77158542502016545090413245809786882778948721859617",
                "72107838435069186155435662884062257473692284509516",
                "20849603980134001723930671666823555245252804609722",
                "53503534226472524250874054075591789781264330331690"
            };

            // Calculate the sum parts according to the strategy described
            // above. We sum each entry at a time, shifting, if any, the
            // most signficant digit in each iteration to the next sum part.
            long[] sums = new long[sumParts];
            for (int i = 0; i < sums.Length; i++)
            {
                sums[i] = 0;
            }

            foreach (string number in numbers)
            {
                int maxParts = Utils.GetMaxPartsOfNumber(number, partSize);
                for (int part = 1; part <= maxParts; part++)
                {
                    long numberPart = Utils.GetPartOfNumber(number, part, partSize);
                    long auxSum = sums[part - 1] + numberPart;
                    string auxSumString = auxSum.ToString();
                    long auxMostSignificantDigit = 0;

                    // If our auxiliar sum got bigger than partSize, then we need
                    // to split the most significat digit from the remaining number.
                    if (auxSumString.Length > partSize)
                    {
                        auxMostSignificantDigit = long.Parse(auxSumString.Substring(0, 1));
                        auxSum = long.Parse(auxSumString.Substring(1));
                    }

                    int currentPartPosition = part - 1;
                    int nextPartPosition = part;
                    sums[currentPartPosition] = auxSum;
                    sums[nextPartPosition] += auxMostSignificantDigit;
                }
            }

            // Finally, get the targetFirstDigitCount digits of the sum.
            // This code will start from the last part, searching for the first
            // significat digit, then gets the requested digits starting from
            // that point (even if spanning multiple parts).
            string firstDigits = "";
            bool alreadyFoundFirstSignificantDigit = false;
            for (int sumPartPosition = sumParts - 1; sumPartPosition >= 0; sumPartPosition--)
            {
                string sumPart = sums[sumPartPosition].ToString()
                    .PadLeft(partSize, '0'); // This is needed so that parts
                                             // with zeros located in the most
                                             // significant positions also count.

                // Console.WriteLine($"Sum Part {sumPartPosition + 1}: {sumPart}");
                foreach (char digit in sumPart)
                {
                    if (alreadyFoundFirstSignificantDigit == false && digit != '0')
                    {
                        alreadyFoundFirstSignificantDigit = true;
                    }
                    if (alreadyFoundFirstSignificantDigit == true)
                    {
                        firstDigits += digit;
                        if (firstDigits.Length == targetFirstDigitCount)
                        {
                            return long.Parse(firstDigits);
                        }
                    }
                }
            }

            // Ouch! Not found? :(
            return -1;
        }
    }
}
