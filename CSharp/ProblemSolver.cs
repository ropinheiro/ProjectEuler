using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System;

namespace ProjectEuler
{
    public class ProblemSolver
    {
        /// <summary>
        /// Set this to true if you want to skip problems whose solution is slow to calculate.
        /// Useful if you want to focus in your current problem without commenting a lot of stuff.
        /// </summary>
        const bool SkipSlow = false;

        public ProblemSolver()
        {
            // ## BEGIN OF HACK ##
            // "Waste" here the time with the reflection overload happening
            // in the 1st time we call the invoker, so that we do not affect
            // the measured time of the 1st problem with extra milliseconds.
            InvokeSolverMethod(1);
            // ## END OF HACK ##
        }

        /// <summary>
        /// Get the number or problems solved so far.
        /// </summary>
        /// <returns>The number of methods with "SolveProblem" in the name.</returns>
        public int NumberOfProblemsSolved
        {
            get
            {
                if (_numberOfProblemsSolved == -1)
                {
                    _numberOfProblemsSolved = this
                        .GetType()
                        .GetMethods()
                        .Where(m => m.Name.Contains("SolveProblem"))
                        .Count();
                }
                return _numberOfProblemsSolved;
            }
        }
        private int _numberOfProblemsSolved = -1;

        /// <summary>
        /// Solve a problem, calculating the time it takes to execute.
        /// </summary>
        /// <param name="problem">A given problem number to solve.</param>
        /// <returns>The solution to the problem, including execution metrics.</returns>
        public SolutionInfo Solve(ProblemInfo problem)
        {
            if (problem.HasSlowResolution && SkipSlow == true)
            {
                return SolutionInfo.GetSkippedSolution(problem.Number);
            }

            SolutionInfo solution = new SolutionInfo(problem.Number);

            var watch = new System.Diagnostics.Stopwatch();
            watch.Start();
            solution.ProblemSolution = InvokeSolverMethod(problem.Number);
            watch.Stop();

            solution.ExecutionTimeInMs = watch.ElapsedMilliseconds;
            solution.Skipped = false;
            solution.SolutionIsCorrect = (solution.ProblemSolution == problem.ExpectedSolution);

            return solution;
        }

        /// <summary>
        /// Runs the problem solver's method given a problem number.
        /// Expects that there is a method with name "SolveProblemXXXX",
        /// where XXXX is the problem number left padded with zeros.
        /// </summary>
        /// <param name="problemNumber">A given problem number.</param>
        /// <returns>The solution of the problem.</returns>
        private long InvokeSolverMethod(int problemNumber)
        {
            MethodInfo solverMethod = this
                .GetType()
                .GetMethod($"SolveProblem{problemNumber.ToString().PadLeft(4, '0')}");

            return (long)solverMethod.Invoke(this, null);
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 1
        /// Multiples of 3 or 5
        /// -------------------------------------------------------------------
        /// If we list all the natural numbers below 10 that are multiples of
        /// 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        /// Find the sum of all the multiples of 3 or 5 below 1000.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #1</returns>
        public long SolveProblem0001()
        {
            long sum = 0;
            for (long i = 1; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    sum += i;
                }
            }
            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 2
        /// Even Fibonacci numbers
        /// -------------------------------------------------------------------
        /// Each new term in the Fibonacci sequence is generated by adding the
        /// previous two terms. By starting with 1 and 2, the first 10 terms
        /// will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        /// By considering the terms in the Fibonacci sequence whose values do
        /// not exceed four million, find the sum of the even-valued terms.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #2</returns>
        public long SolveProblem0002()
        {
            long sum = 0;
            long previousValue1 = 0;
            long previousValue2 = 1;
            long currentValue = previousValue1 + previousValue2;

            while (currentValue < 4000000)
            {
                if (currentValue % 2 == 0)
                {
                    sum += currentValue;
                }

                previousValue1 = previousValue2;
                previousValue2 = currentValue;
                currentValue = previousValue1 + previousValue2;
            }

            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 3
        /// Largest prime factor
        /// -------------------------------------------------------------------
        /// The prime factors of 13195 are 5, 7, 13 and 29.
        /// What is the largest prime factor of the number 600851475143 ?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #3</returns>
        public long SolveProblem0003()
        {
            long number = 600851475143;

            // Strategy:

            // PART 1 => start from 2 until M, where M << K (e.g. M = 10000)
            //           until we hit a number N <= M for which K is divisible
            //           if M is hit, then use N = M.

            // PART 2 => now that we have N as the smallest number for which
            //           K is visible, then we can search now from K/N until N
            //           until we get a N < T < K/N value that will be the
            //           greatest number for which K is visible.

            // Note that below N and above K/N it is proved that there are no
            // numbers for which K will be divisible, therefore, it is the
            // shortest interval we can use for the search.

            // Optimization notes:
            // #1 - The number is odd, therefore, is not divisible by any even number.
            // #2 - The number is does not end in 0 or 5, therefore, is not divisible by any number ending in 0 or 5.
            // #3 - The number is not divisible by 3, therefore, not divisible by any multiple of 3.

            // #########################
            // ### STRATEGY - PART 1 ###
            // #########################

            // Why 7? See Hints #1, #2, #3.
            long minorDivisibleNumber = 7;
            long stopAt = 10000;
            while (number % minorDivisibleNumber != 0 && minorDivisibleNumber <= stopAt)
            {
                // Why +2? See Hint #1. 
                minorDivisibleNumber = minorDivisibleNumber + 2;
            }
            // DEBUG
            // System.Console.WriteLine($"Stopped at: {minorDivisibleNumber}. ");


            // #########################
            // ### STRATEGY - PART 2 ###
            // #########################

            long currentTentative = number / minorDivisibleNumber;

            // Why %2? See Hint #1.
            currentTentative = (currentTentative % 2 == 0 ? currentTentative-- : currentTentative);

            // Why skipFives? See Hint #2.
            long skipFives = currentTentative % 5;
            if (skipFives == 0)
            {
                currentTentative = currentTentative - 2;
                skipFives = 4;
            }
            else
            {
                // We are "converting" the mod 5 to a sequence from
                // 4 to 0 such that when reaching 0, skils the number
                // because it currently ends in 5. Yeah, cumbersome,
                // but it is a 20% improvement in the speed.
                if (skipFives == 1) skipFives = 3;
                else if (skipFives == 2) skipFives = 1;
                else if (skipFives == 3) skipFives = 4;
                else if (skipFives == 4) skipFives = 2;
            }

            // DEBUG
            // var watch = new System.Diagnostics.Stopwatch();
            // watch.Start();
            // long iterations = 0;
            // long count = 0;
            // long step = 100000000;

            // Worst case, we reach 1.
            // That is guaranteed to cause the cycle to stop.
            while (number % currentTentative != 0 || !Utils.IsPrime(currentTentative))
            {
                // Why -2? See Hint #1.
                currentTentative = currentTentative - 2;

                // Why skipFives? See Hint #2.
                skipFives = skipFives - 1;
                if (skipFives == 0)
                {
                    currentTentative = currentTentative - 2;
                    skipFives = 4;
                }

                // DEBUG
                // if (++iterations > step)
                // {
                //     iterations = 0;
                //     count += step;
                //     System.Console.WriteLine($"So far: {count} iterations, reached number {currentTentative} in {watch.ElapsedMilliseconds / 1000} s. ");
                // }
            }

            // DEBUG
            // watch.Stop();

            return currentTentative;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 4
        /// Largest palindrome product
        /// -------------------------------------------------------------------
        /// A palindromic number reads the same both ways.  The largest
        /// palindrome made from the product of two 2-digit numbers is
        /// 9009 = 91 Ã— 99. Find the largest palindrome made from the product
        /// of two 3-digit numbers.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #4</returns>
        public long SolveProblem0004()
        {
            long largestPalindromeSoFar = 0;
            long currentProduct = 0;

            for (int i = 999; i >= 100; i--)
            {
                for (int j = 999; j >= 100; j--)
                {
                    currentProduct = i * j;
                    if (currentProduct > largestPalindromeSoFar && Utils.IsPalindrome(currentProduct))
                    {
                        largestPalindromeSoFar = currentProduct;
                    }
                }
            }

            return largestPalindromeSoFar;
        }
    }
}