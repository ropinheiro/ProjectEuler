using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System;

namespace ProjectEuler
{
    public class ProblemSolver
    {
        /// <summary>
        /// Set this to true if you want to skip problems whose solution is slow to calculate.
        /// Useful if you want to focus in your current problem without commenting a lot of stuff.
        /// </summary>
        const bool SkipSlow = false;

        public ProblemSolver()
        {
            // ## BEGIN OF HACK ##
            // "Waste" here the time with the reflection overload happening
            // in the 1st time we call the invoker, so that we do not affect
            // the measured time of the 1st problem with extra milliseconds.
            InvokeSolverMethod(1);
            // ## END OF HACK ##
        }

        /// <summary>
        /// Get the number or problems solved so far.
        /// </summary>
        /// <returns>The number of methods with "SolveProblem" in the name.</returns>
        public int NumberOfProblemsSolved
        {
            get
            {
                if (_numberOfProblemsSolved == -1)
                {
                    _numberOfProblemsSolved = this
                        .GetType()
                        .GetMethods()
                        .Where(m => m.Name.Contains("SolveProblem"))
                        .Count();
                }
                return _numberOfProblemsSolved;
            }
        }
        private int _numberOfProblemsSolved = -1;

        /// <summary>
        /// Solve a problem, calculating the time it takes to execute.
        /// </summary>
        /// <param name="problem">A given problem number to solve.</param>
        /// <returns>The solution to the problem, including execution metrics.</returns>
        public SolutionInfo Solve(ProblemInfo problem)
        {
            if (problem.HasSlowResolution && SkipSlow == true)
            {
                return SolutionInfo.GetSkippedSolution(problem.Number);
            }

            SolutionInfo solution = new SolutionInfo(problem.Number);

            var watch = new System.Diagnostics.Stopwatch();
            watch.Start();
            solution.ProblemSolution = InvokeSolverMethod(problem.Number);
            watch.Stop();

            solution.ExecutionTimeInMs = watch.ElapsedMilliseconds;
            solution.Skipped = false;
            solution.SolutionIsCorrect = (solution.ProblemSolution == problem.ExpectedSolution);

            return solution;
        }

        /// <summary>
        /// Runs the problem solver's method given a problem number.
        /// Expects that there is a method with name "SolveProblemXXXX",
        /// where XXXX is the problem number left padded with zeros.
        /// </summary>
        /// <param name="problemNumber">A given problem number.</param>
        /// <returns>The solution of the problem.</returns>
        private long InvokeSolverMethod(int problemNumber)
        {
            MethodInfo solverMethod = this
                .GetType()
                .GetMethod($"SolveProblem{problemNumber.ToString().PadLeft(4, '0')}");

            return (long)solverMethod.Invoke(this, null);
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 1
        /// Multiples of 3 or 5
        /// -------------------------------------------------------------------
        /// If we list all the natural numbers below 10 that are multiples of
        /// 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
        /// Find the sum of all the multiples of 3 or 5 below 1000.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #1</returns>
        public long SolveProblem0001()
        {
            long sum = 0;
            for (long i = 1; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    sum += i;
                }
            }
            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 2
        /// Even Fibonacci numbers
        /// -------------------------------------------------------------------
        /// Each new term in the Fibonacci sequence is generated by adding the
        /// previous two terms. By starting with 1 and 2, the first 10 terms
        /// will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        /// By considering the terms in the Fibonacci sequence whose values do
        /// not exceed four million, find the sum of the even-valued terms.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #2</returns>
        public long SolveProblem0002()
        {
            long sum = 0;
            long previousValue1 = 0;
            long previousValue2 = 1;
            long currentValue = previousValue1 + previousValue2;

            while (currentValue < 4000000)
            {
                if (currentValue % 2 == 0)
                {
                    sum += currentValue;
                }

                previousValue1 = previousValue2;
                previousValue2 = currentValue;
                currentValue = previousValue1 + previousValue2;
            }

            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 3
        /// Largest prime factor
        /// -------------------------------------------------------------------
        /// The prime factors of 13195 are 5, 7, 13 and 29.
        /// What is the largest prime factor of the number 600851475143 ?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #3</returns>
        public long SolveProblem0003()
        {
            long number = 600851475143;

            // Strategy:

            // PART 1 => start from 2 until M, where M << K (e.g. M = 10000)
            //           until we hit a number N <= M for which K is divisible
            //           if M is hit, then use N = M.

            // PART 2 => now that we have N as the smallest number for which
            //           K is visible, then we can search now from K/N until N
            //           until we get a N < T < K/N value that will be the
            //           greatest number for which K is visible.

            // Note that below N and above K/N it is proved that there are no
            // numbers for which K will be divisible, therefore, it is the
            // shortest interval we can use for the search.

            // Optimization notes:
            // #1 - The number is odd, therefore, is not divisible by any even number.
            // #2 - The number is does not end in 0 or 5, therefore, is not divisible by any number ending in 0 or 5.
            // #3 - The number is not divisible by 3, therefore, not divisible by any multiple of 3.

            // #########################
            // ### STRATEGY - PART 1 ###
            // #########################

            // Why 7? See Hints #1, #2, #3.
            long minorDivisibleNumber = 7;
            long stopAt = 10000;
            while (number % minorDivisibleNumber != 0 && minorDivisibleNumber <= stopAt)
            {
                // Why +2? See Hint #1. 
                minorDivisibleNumber = minorDivisibleNumber + 2;
            }
            // DEBUG
            // System.Console.WriteLine($"Stopped at: {minorDivisibleNumber}. ");


            // #########################
            // ### STRATEGY - PART 2 ###
            // #########################

            long currentTentative = number / minorDivisibleNumber;

            // Why %2? See Hint #1.
            currentTentative = (currentTentative % 2 == 0 ? currentTentative-- : currentTentative);

            // Why skipFives? See Hint #2.
            long skipFives = currentTentative % 5;
            if (skipFives == 0)
            {
                currentTentative = currentTentative - 2;
                skipFives = 4;
            }
            else
            {
                // We are "converting" the mod 5 to a sequence from
                // 4 to 0 such that when reaching 0, skils the number
                // because it currently ends in 5. Yeah, cumbersome,
                // but it is a 20% improvement in the speed.
                if (skipFives == 1) skipFives = 3;
                else if (skipFives == 2) skipFives = 1;
                else if (skipFives == 3) skipFives = 4;
                else if (skipFives == 4) skipFives = 2;
            }

            // DEBUG
            // var watch = new System.Diagnostics.Stopwatch();
            // watch.Start();
            // long iterations = 0;
            // long count = 0;
            // long step = 100000000;

            // Worst case, we reach 1.
            // That is guaranteed to cause the cycle to stop.
            while (number % currentTentative != 0 || !Utils.IsPrime(currentTentative))
            {
                // Why -2? See Hint #1.
                currentTentative = currentTentative - 2;

                // Why skipFives? See Hint #2.
                skipFives = skipFives - 1;
                if (skipFives == 0)
                {
                    currentTentative = currentTentative - 2;
                    skipFives = 4;
                }

                // DEBUG
                // if (++iterations > step)
                // {
                //     iterations = 0;
                //     count += step;
                //     System.Console.WriteLine($"So far: {count} iterations, reached number {currentTentative} in {watch.ElapsedMilliseconds / 1000} s. ");
                // }
            }

            // DEBUG
            // watch.Stop();

            return currentTentative;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 4
        /// Largest palindrome product
        /// -------------------------------------------------------------------
        /// A palindromic number reads the same both ways.  The largest
        /// palindrome made from the product of two 2-digit numbers is
        /// 9009 = 91 × 99. Find the largest palindrome made from the product
        /// of two 3-digit numbers.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #4</returns>
        public long SolveProblem0004()
        {
            long largestPalindromeSoFar = 0;
            long currentProduct = 0;

            for (int i = 999; i >= 100; i--)
            {
                for (int j = 999; j >= 100; j--)
                {
                    currentProduct = i * j;
                    if (currentProduct > largestPalindromeSoFar && Utils.IsPalindrome(currentProduct))
                    {
                        largestPalindromeSoFar = currentProduct;
                    }
                }
            }

            return largestPalindromeSoFar;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 5
        /// Smallest multiple
        /// -------------------------------------------------------------------
        /// 2520 is the smallest number that can be divided by each of the
        /// numbers from 1 to 10 without any remainder.
        /// What is the smallest positive number that is evenly divisible by
        /// all of the numbers from 1 to 20?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #5</returns>
        public long SolveProblem0005()
        {
            // STRATEGY:
            // - Search one mod at a time: first smallest number with mod 1 == 0,
            //   then mod 2, then mod 3 ... until mod 20.
            // - Step by the last smallest number, because e.g. if we have the
            //   smallest number with mod 5, then only multiples of that
            //   smallest number will be divisible by all numbers from 1 to 5.

            // Note that we could start with:
            //      long currentMinimum = 2520;
            //      long currentModule = 11;
            // ... as we already those values from the problem description,
            // but this way the code is more generic.

            long targetModule = 20;
            long currentModule = 1;
            long currentMinimum = 1;
            long currentStep = currentMinimum;

            while (currentModule <= targetModule)
            {
                if (currentMinimum % currentModule == 0)
                {
                    currentStep = currentMinimum;
                    currentModule++;
                }
                else
                {
                    currentMinimum += currentStep;
                }
            }

            return currentMinimum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 6
        /// Sum square difference
        /// -------------------------------------------------------------------
        /// The sum of the squares of the first ten natural numbers is:
        ///    1*1 + 2*2 + ... + 10*10 = 385
        ///    
        /// The square of the sum of the first ten natural numbers is:
        ///    (1+2+...+10)^2 = 55^2 = 2640
        ///    
        /// Hence the difference between the sum of the squares of the first
        /// ten natural numbers and the square of the sum is:
        ///        3025 - 385 = 2640
        ///    
        /// Find the difference between the sum of the squares of the first
        /// one hundred natural numbers and the square of the sum.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #6</returns>
        public long SolveProblem0006()
        {
            long targetNumber = 100;
            long squaresSum = 0;
            long simpleSum = 0;

            for (long i = 1; i <= targetNumber; i++)
            {
                squaresSum += i * i;
                simpleSum += i;
            }

            return (simpleSum * simpleSum) - squaresSum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 7
        /// 10001st prime
        /// -------------------------------------------------------------------
        /// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
        /// we can see that the 6th prime is 13.
        /// What is the 10 001st prime number?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #7</returns>
        public long SolveProblem0007()
        {
            // Optimization Hints:
            // #1 - No odd numbers (all are divisible by 2)
            // #2 - No numbers ending in 5 (all are divisible by 5)
            //      (note: no need to use hint #2, fast enough)

            long primeCount = 1;
            long targetCount = 10001;
            long currentPrime = 2;
            long currentNumber = currentPrime + 1;

            while (primeCount < targetCount)
            {
                if (Utils.IsPrime(currentNumber))
                {
                    currentPrime = currentNumber;
                    primeCount++;
                }

                // Why 2? See Hint #1.
                currentNumber = currentNumber + 2;
            }

            return currentPrime;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 8
        /// Largest product in a series
        /// -------------------------------------------------------------------
        /// The four adjacent digits in the 1000-digit number that have the
        /// greatest product are 9 × 9 × 8 × 9 = 5832.
        /// 
        /// 73167176531330624919225119674426574742355349194934
        /// 96983520312774506326239578318016984801869478851843
        /// 85861560789112949495459501737958331952853208805511
        /// 12540698747158523863050715693290963295227443043557
        /// 66896648950445244523161731856403098711121722383113
        /// 62229893423380308135336276614282806444486645238749
        /// 30358907296290491560440772390713810515859307960866
        /// 70172427121883998797908792274921901699720888093776
        /// 65727333001053367881220235421809751254540594752243
        /// 52584907711670556013604839586446706324415722155397
        /// 53697817977846174064955149290862569321978468622482
        /// 83972241375657056057490261407972968652414535100474
        /// 82166370484403199890008895243450658541227588666881
        /// 16427171479924442928230863465674813919123162824586
        /// 17866458359124566529476545682848912883142607690042
        /// 24219022671055626321111109370544217506941658960408
        /// 07198403850962455444362981230987879927244284909188
        /// 84580156166097919133875499200524063689912560717606
        /// 05886116467109405077541002256983155200055935729725
        /// 71636269561882670428252483600823257530420752963450
        /// 
        /// Find the thirteen adjacent digits in the 1000-digit number that
        /// have the greatest product. What is the value of this product?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #8</returns>
        public long SolveProblem0008()
        {
            string bigNumber = "73167176531330624919225119674426574742355349194934"
                             + "96983520312774506326239578318016984801869478851843"
                             + "85861560789112949495459501737958331952853208805511"
                             + "12540698747158523863050715693290963295227443043557"
                             + "66896648950445244523161731856403098711121722383113"
                             + "62229893423380308135336276614282806444486645238749"
                             + "30358907296290491560440772390713810515859307960866"
                             + "70172427121883998797908792274921901699720888093776"
                             + "65727333001053367881220235421809751254540594752243"
                             + "52584907711670556013604839586446706324415722155397"
                             + "53697817977846174064955149290862569321978468622482"
                             + "83972241375657056057490261407972968652414535100474"
                             + "82166370484403199890008895243450658541227588666881"
                             + "16427171479924442928230863465674813919123162824586"
                             + "17866458359124566529476545682848912883142607690042"
                             + "24219022671055626321111109370544217506941658960408"
                             + "07198403850962455444362981230987879927244284909188"
                             + "84580156166097919133875499200524063689912560717606"
                             + "05886116467109405077541002256983155200055935729725"
                             + "71636269561882670428252483600823257530420752963450";

            int targetSequence = 13;
            long currentGreatestProduct = 0;

            for (int i = 0; i < bigNumber.Length - targetSequence; i++)
            {
                string extract = bigNumber.Substring(i, targetSequence);

                // Optimization hint: if there is a zero, the product will be zero.
                // therefore, ignore this sequence, and go for the next one.
                if (extract.Contains("0"))
                {
                    continue;
                }

                long product = 1;
                foreach (char c in extract)
                {
                    // Convert char to number by subtracting to it the ASCII value of '0'.
                    product *= (c - '0');
                }

                if (product > currentGreatestProduct)
                {
                    currentGreatestProduct = product;
                }
            }

            return currentGreatestProduct;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 9
        /// Special Pythagorean triplet
        /// -------------------------------------------------------------------
        /// A Pythagorean triplet is a set of three natural numbers, a < b < c,
        /// for which:
        ///        a^2 + b^2 = c^2
        ///        
        /// For example:
        ///        3^2 + 4^2 = 9 + 16 = 25 = 5^2.
        ///        
        /// There exists exactly one Pythagorean triplet for which:
        ///        a + b + c = 1000.
        ///        
        /// Find the product abc.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #9</returns>
        public long SolveProblem0009()
        {
            int targetSum = 1000;

            for (int a = 1; a < 1000; a++)
            {
                for (int b = 1; b < 1000; b++)
                {
                    for (int c = 1; c < 1000; c++)
                    {
                        if (a * a + b * b == c * c)
                        {
                            if (a + b + c == targetSum)
                            {
                                return a * b * c;
                            }
                        }

                    }
                }
            }

            return -1;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 10
        /// Summation of primes
        /// -------------------------------------------------------------------
        /// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
        /// Find the sum of all the primes below two million.
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #10</returns>
        public long SolveProblem0010()
        {
            long targetPrimeNumber = 2000000;
            long sum = 0;

            for (long i = 2; i < targetPrimeNumber; i++)
            {
                if (Utils.IsPrime(i))
                {
                    sum += i;
                }
            }

            return sum;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 11
        /// Largest product in a grid
        /// -------------------------------------------------------------------
        /// In the 20×20 grid below, four numbers along a diagonal line have
        /// been marked in red [Note: I used *xx* here, instead].
        /// 
        /// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
        /// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
        /// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
        /// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
        /// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
        /// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
        /// 32 98 81 28 64 23 67 10 *26* 38 40 67 59 54 70 66 18 38 64 70
        /// 67 26 20 68 02 62 12 20 95 *63* 94 39 63 08 40 91 66 49 94 21
        /// 24 55 58 05 66 73 99 26 97 17 *78* 78 96 83 14 88 34 89 63 72
        /// 21 36 23 09 75 00 76 44 20 45 35 *14* 00 61 33 97 34 31 33 95
        /// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
        /// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
        /// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
        /// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
        /// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
        /// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
        /// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
        /// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
        /// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
        /// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
        /// 
        /// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
        /// What is the greatest product of four adjacent numbers in the
        /// same direction (up, down, left, right, or diagonally) in the
        /// 20×20 grid?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #11</returns>
        public long SolveProblem0011()
        {
            // Strategy:
            // 1. Create an array with the numbers
            // 2. Make 2 nested cycles from 0 to N-4 in both directions
            // 3. In each step we get a square of 4x4 to check
            // 4. Nested cycle to check ortogonal rows
            // 5. Simple cycle to check diagonal rows

            int targetNumberCount = 4;
            long greatestProduct = 0;

            // 1. Create an array with the numbers
            int[,] array = new int[,]
            {
                { 08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08 },
                { 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00 },
                { 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65 },
                { 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91 },
                { 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80 },
                { 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50 },
                { 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70 },
                { 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21 },
                { 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72 },
                { 21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95 },
                { 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92 },
                { 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57 },
                { 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58 },
                { 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40 },
                { 04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66 },
                { 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69 },
                { 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36 },
                { 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16 },
                { 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54 },
                { 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48 }
            };

            // 2. Make 2 nested cycles from 0 to N-targetNumberCount in both directions
            for (int i = 0; i < array.GetLength(0) - targetNumberCount; i++)
            {
                // 3. In each step we get a square of targetNumberCount x targetNumberCount to check
                for (int j = 0; j < array.GetLength(1) - targetNumberCount; j++)
                {
                    // 4. Nested cycle to check ortogonal rows
                    for (int a = 0; a < targetNumberCount; a++)
                    {
                        long rowProduct = 1;
                        long columnProduct = 1;
                        for (int b = 0; b < targetNumberCount; b++)
                        {
                            rowProduct *= array[i + a, j + b];
                            columnProduct *= array[i + b, j + a];
                        }
                        if (rowProduct > greatestProduct)
                        {
                            greatestProduct = rowProduct;
                        }
                        if (columnProduct > greatestProduct)
                        {
                            greatestProduct = columnProduct;
                        }
                    }

                    // 5. Simple cycle to check diagonal rows
                    long backslashProduct = 1;
                    long forwardslashProduct = 1;
                    for (int s = 0; s < targetNumberCount; s++)
                    {
                        backslashProduct *= array[i + s, j + s];
                        forwardslashProduct *= array[i + targetNumberCount - 1 - s, j + s];
                    }
                    if (backslashProduct > greatestProduct)
                    {
                        greatestProduct = backslashProduct;
                    }
                    if (forwardslashProduct > greatestProduct)
                    {
                        greatestProduct = forwardslashProduct;
                    }

                }
            }

            return greatestProduct;
        }

        /// <summary>
        /// -------------------------------------------------------------------
        /// Problem 12
        /// Highly divisible triangular number
        /// -------------------------------------------------------------------
        /// The sequence of triangle numbers is generated by adding the natural
        /// numbers. So the 7th triangle number would be:
        ///          1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
        ///
        /// The first ten terms would be:
        ///          1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        /// 
        /// Let us list the factors of the first seven triangle numbers:
        ///  1: 1
        ///  3: 1, 3
        ///  6: 1, 2, 3, 6
        /// 10: 1, 2, 5, 10
        /// 15: 1, 3, 5, 15
        /// 21: 1, 3, 7, 21
        /// 28: 1, 2, 4, 7, 14, 28
        /// 
        /// We can see that 28 is the first triangle number to have over
        /// five divisors. What is the value of the first triangle number
        /// to have over five hundred divisors?
        /// -------------------------------------------------------------------
        /// </summary>
        /// <returns>Solution for Project Euler #12</returns>
        public long SolveProblem0012()
        {
            long targetDivisorCount = 500;

            long currentTriangle = 0;
            for (long x = 1; x < long.MaxValue; x++)
            {
                // Just accumulate, no need to recalculate sums from 1 all the time.
                currentTriangle += x;

                // We always start counting 2: the 1 and the currentTriangle itself.
                int divisorsCount = 2;
                long currentDivisor = 2;
                long maxDivisorToTest = (long)Math.Sqrt(currentTriangle);
                while (currentDivisor <= maxDivisorToTest)
                {
                    if (currentTriangle % currentDivisor == 0)
                    {
                        divisorsCount++;

                        // Now that we found a smaller divisor A, we have also
                        // a larger divisor B such that AxB=currentTriangle.
                        long otherDivisor = currentTriangle / currentDivisor;

                        // Of course we do not want to count it twice if we
                        // happen to find the square root of currentTriangle!
                        if (currentDivisor != otherDivisor)
                        {
                            divisorsCount++;
                        }
                    }

                    if (divisorsCount >= targetDivisorCount)
                    {
                        return currentTriangle;
                    }

                    currentDivisor++;
                }
            }

            // Oops... not found?
            return -1;
        }
    }
}
